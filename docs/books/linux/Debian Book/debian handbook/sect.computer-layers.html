<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>B.3. Inner Workings of a Computer: the Different Layers Involved</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="generator" content="publican 3.0" /><meta name="package" content="Debian-debian-handbook-6.0-en-US-1.0-1" /><meta name="keywords" content="BIOS, Kernel, Unix, Process, Hierarchy, Basic Commands" /><link rel="home" href="index.html" title="The Debian Administrator's Handbook" /><link rel="up" href="short-remedial-course.html" title="Appendix B. Short Remedial Course" /><link rel="prev" href="sect.filesystem-hierarchy.html" title="B.2. Organization of the Filesystem Hierarchy" /><link rel="next" href="sect.kernel-role-and-tasks.html" title="B.4. Some Tasks Handled by the Kernel" /></head><body><p class="hidden" id="title"><a class="left" href="http://www.debian.org"><img src="Common_Content/images/image_left.png" alt="Product Site" /></a><a class="right" href="http://debian-handbook.info"><img src="Common_Content/images/image_right.png" alt="Documentation Site" /></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="sect.filesystem-hierarchy.html"><strong>Prev</strong></a></li><li class="home">The Debian Administrator's Handbook</li><li class="next"><a accesskey="n" href="sect.kernel-role-and-tasks.html"><strong>Next</strong></a></li></ul><div class="section"><div class="titlepage"><div><div><h2 class="title" id="sect.computer-layers">B.3. Inner Workings of a Computer: the Different Layers Involved</h2></div></div></div><div class="para"><p></p>
			A computer is often considered as something rather abstract, and the externally visible interface is much simpler than its internal complexity. Such complexity comes in part from the number of pieces involved. However, these pieces can be viewed in layers, where a layer only interacts with those immediately above or below.
		</div><div class="para"><p></p>
			An end-user can get by without knowing these details… as long as everything works. When confronting a problem such as, “The internet doesn't work!”, the first thing to do is to identify in which layer the problem originates. Is the network card (hardware) working? Is it recognized by the computer? Does the Linux kernel see it? Are the network parameters properly configured? All these questions isolate an appropriate layer and focus on a potential source of the problem.
		</div><div class="section"><div class="titlepage"><div><div><h3 class="title" id="section.materiel">B.3.1. The Deepest Layer: the Hardware</h3></div></div></div><a id="idp11533216" class="indexterm"></a><a id="idp11533696" class="indexterm"></a><a id="idp9499504" class="indexterm"></a><a id="idp9499984" class="indexterm"></a><a id="idp9500448" class="indexterm"></a><a id="idp9500928" class="indexterm"></a><a id="idp9501408" class="indexterm"></a><a id="idp9501888" class="indexterm"></a><div class="para"><p></p>
				Let us start with a basic reminder that a computer is, first and foremost, a set of hardware elements. There is generally a main board, with one (or more) processor(s), some RAM, device controllers, and extension slots for option boards (for other device controllers). Most noteworthy among these controllers are IDE (Parallel ATA), SCSI and Serial ATA, for connecting to storage devices such as hard disks. Other controllers include USB, which is able to host a great variety of devices (ranging from webcams to thermometers, from keyboards to home automation systems) and IEEE_1394 (Firewire). These controllers often allow connecting several devices so the complete subsystem handled by a controller is therefore usually known as a “bus”. Option boards include graphics cards (where monitor screens will be plugged in to), sound cards, network interface cards, and so on. Some main boards are pre-built with these features, and don't need option boards.
			</div><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>IN PRACTICE</em></span> Checking that the hardware works</h6></div></div></div><div class="para"><p></p>
				Checking that a piece of hardware works can be tricky. On the other hand, proving that it doesn't work is sometimes quite simple.
			</div><div class="para"><p></p>
				A hard disk drive is made of spinning platters and moving magnetic heads. When a hard disk is powered up, the platter motor makes a characteristic whir. It also dissipates energy as heat. Consequently, a hard disk drive that stays cold and silent when powered up is broken.
			</div><div class="para"><p></p>
				Network cards often include LEDs displaying the state of the link. If a cable is plugged in and leads to a working network hub or switch, at least one LED will be on. If no LEDs lights, either the card itself, the network device, or the cable between them, is faulty. The next step is therefore testing each component individually.
			</div><div class="para"><p></p>
				Some option boards — especially 3D video cards — include cooling devices, such as heat sinks and/or fans. If the fan does not spin even though the card is powered up, a plausible explanation is the card overheated. This also applies to the main processor(s) located on the main board.
			</div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title" id="section.bios">B.3.2. The Starter: the BIOS</h3></div></div></div><a id="idp9506720" class="indexterm"></a><div class="para"><p></p>
				Hardware, on its own, is unable to perform useful tasks without a corresponding piece of software driving it. Controlling and interacting with the hardware is the purpose of the operating system and applications. These, in turn, require functional hardware to run.
			</div><div class="para"><p></p>
				This symbiosis between hardware and software does not happen on its own. When the computer is first powered up, some initial setup is required. This role is assumed by the BIOS, a tiny piece of software embedded into the main board that runs automatically upon power-up. Its primary task is searching for software it can hand over control to. Usually, this involves looking for the first hard disk with a boot sector (also known as the <span class="emphasis"><em>master boot record</em></span> or <acronym class="acronym">MBR</acronym>), loading that boot sector, and running it. From then on, the BIOS is usually not involved (until the next boot).
			</div><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>TOOL</em></span> Setup, the BIOS configuration tool</h6></div></div></div><a id="idp9509496" class="indexterm"></a><div class="para"><p></p>
				The BIOS also contains a piece of software called Setup, designed to allow configuring aspects of the computer. In particular, it allows choosing which boot device is preferred (for instance, the floppy disk or CD-ROM drive), setting the system clock, and so on. Starting Setup usually involves pressing a key very soon after the computer is powered on. This key is often <span class="keycap"><strong>Del</strong></span> or <span class="keycap"><strong>Esc</strong></span>, sometimes <span class="keycap"><strong>F2</strong></span> or <span class="keycap"><strong>F10</strong></span>. Most of the time, the choice is flashed on screen while booting.
			</div></div><div class="para"><p></p>
				The boot sector, in turn, contains another tiny piece of software, called the bootloader, whose purpose is to find and run an operating system. Since this bootloader is not embedded in the main board but loaded from disk, it can be smarter than the BIOS, which explains why the BIOS does not load the operating system by itself. For instance, the bootloader (often GRUB on Linux systems) can list the available operating systems and ask the user to choose one. Usually, a time-out and default choice is provided. Sometimes the user can also choose to add parameters to pass to the kernel, and so on. Eventually, a kernel is found, loaded into memory, and executed.
			</div><div class="para"><p></p>
				The BIOS is also in charge of detecting and initializing a number of devices. Obviously, this includes the IDE/SATA devices (usually hard disk(s) and CD/DVD-ROM drives), but also PCI devices. Detected devices are often listed on screen during the boot process. If this list goes by too fast, use the <span class="keycap"><strong>Pause</strong></span> key to freeze it for long enough to read. Installed PCI devices that don't appear, are a bad omen. At worst, the device is faulty. At best, it is merely incompatible with the current version of the BIOS or main board. PCI specifications evolve, and old main boards are not guaranteed to handle newer PCI devices.
			</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title" id="section.noyau">B.3.3. The Kernel</h3></div></div></div><div class="para"><p></p>
				Both the BIOS and the bootloader only run for a few seconds each; now we're getting to the first piece of software that runs for a longer time, the operating system kernel. This kernel assumes the role of a conductor in an orchestra, and ensures coordination between hardware and software. This role involves several tasks including: driving hardware, managing processes, users and permissions, the filesystem, and so on. The kernel provides a common base to all other programs on the system.
			</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title" id="section.userspace-presentation">B.3.4. The User Space</h3></div></div></div><div class="para"><p></p>
				Although everything that happens outside of the kernel can be lumped together under “user-space”, we can still separate it into software layers. However, their interactions are more complex than before, and the classifications may not be as simple. An application commonly uses libraries, which in turn involve the kernel, but the communications can also involve other programs, or even many libraries calling each other.
			</div></div></div><div id="site_footer"></div><script type="text/javascript">
		$("#site_footer").load("../../../../../footer.html");
	</script><ul class="docnav"><li class="previous"><a accesskey="p" href="sect.filesystem-hierarchy.html"><strong>Prev</strong>B.2. Organization of the Filesystem Hierarchy</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="sect.kernel-role-and-tasks.html"><strong>Next</strong>B.4. Some Tasks Handled by the Kernel</a></li></ul></body></html>
