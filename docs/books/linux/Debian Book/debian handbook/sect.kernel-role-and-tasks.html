<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>B.4. Some Tasks Handled by the Kernel</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="generator" content="publican 3.0" /><meta name="package" content="Debian-debian-handbook-6.0-en-US-1.0-1" /><meta name="keywords" content="BIOS, Kernel, Unix, Process, Hierarchy, Basic Commands" /><link rel="home" href="index.html" title="The Debian Administrator's Handbook" /><link rel="up" href="short-remedial-course.html" title="Appendix B. Short Remedial Course" /><link rel="prev" href="sect.computer-layers.html" title="B.3. Inner Workings of a Computer: the Different Layers Involved" /><link rel="next" href="sect.user-space.html" title="B.5. The User Space" /></head><body><p class="hidden" id="title"><a class="left" href="http://www.debian.org"><img src="Common_Content/images/image_left.png" alt="Product Site" /></a><a class="right" href="http://debian-handbook.info"><img src="Common_Content/images/image_right.png" alt="Documentation Site" /></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="sect.computer-layers.html"><strong>Prev</strong></a></li><li class="home">The Debian Administrator's Handbook</li><li class="next"><a accesskey="n" href="sect.user-space.html"><strong>Next</strong></a></li></ul><div class="section"><div class="titlepage"><div><div><h2 class="title" id="sect.kernel-role-and-tasks">B.4. Some Tasks Handled by the Kernel</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title" id="section.pilotage-materiel">B.4.1. Driving the Hardware</h3></div></div></div><div class="para"><p></p>
				The kernel is, first and foremost, tasked with controlling the hardware parts, detecting them, switching them on when the computer is powered on, and so on. It also makes them available to higher-level software with a simplified programming interface, so applications can take advantage of devices without having to worry about details such as which extension slot the option board is plugged into. The programming interface also provides an abstraction layer; this allows video-conferencing software, for example, to use a webcam independently of its make and model. The software can just use the <span class="emphasis"><em>Video for Linux</em></span> (V4L) interface, and the kernel translates the function calls of this interface into the actual hardware commands needed by the specific webcam in use.
			</div><div class="para"><p></p>
				<a id="idp14439376" class="indexterm"></a>
				 <a id="idp14439936" class="indexterm"></a>
				 <a id="idp14440496" class="indexterm"></a>
				 <a id="idp14441056" class="indexterm"></a>
				 The kernel exports many details about detected hardware through the <code class="filename">/proc/</code> and <code class="filename">/sys/</code> virtual filesystems. Several tools summarize those details. Among them, <code class="command">lspci</code> (in the <span class="pkg pkg">pciutils</span> package) lists PCI devices, <code class="command">lsusb</code> (in the <span class="pkg pkg">usbutils</span> package) lists USB devices, and <code class="command">lspcmcia</code> (in the <span class="pkg pkg">pcmciautils</span> package) lists PCMCIA cards. These tools are very useful for identifying the exact model of a device. This identification also allows more precise searches on the web, which in turn, lead to more relevant documents.
			</div><div class="example"><h6>Example B.1. Example of information provided by <code class="command">lspci</code> and <code class="command">lsusb</code></h6><div class="example-contents"><pre class="screen">
<code class="computeroutput">$ </code><strong class="userinput"><code>lspci</code></strong>
<code class="computeroutput">[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </code><strong class="userinput"><code>lsusb</code></strong>
<code class="computeroutput">Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</code>
</pre></div></div><br class="example-break" /><div class="para"><p></p>
				These programs have a <code class="literal">-v</code> option, that lists much more detailed (but usually not necessary) information. Finally, the <code class="command">lsdev</code> command (in the <span class="pkg pkg">procinfo</span> package) lists communication resources used by devices.
			</div><div class="para"><p></p>
				Applications often access devices by way of special files created within <code class="filename">/dev/</code> (see sidebar <a class="xref" href="sect.creating-accounts.html#cadre.fichiers-speciaux"><span class="emphasis"><em>BACK TO BASICS</em></span> Device access permissions</a>). These are special files that represent disk drives (for instance, <code class="filename">/dev/hda</code> and <code class="filename">/dev/sdc</code>), partitions (<code class="filename">/dev/hda1</code> or <code class="filename">/dev/sdc3</code>), mice (<code class="filename">/dev/input/mouse0</code>), keyboards (<code class="filename">/dev/input/event0</code>), soundcards (<code class="filename">/dev/snd/*</code>), serial ports (<code class="filename">/dev/ttyS*</code>), and so on.
			</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title" id="section.systemes-fichiers">B.4.2. Filesystems</h3></div></div></div><a id="idp14451816" class="indexterm"></a><a id="idp14452296" class="indexterm"></a><div class="para"><p></p>
				Filesystems are one of the most prominent aspects of the kernel. Unix systems merge all the file storages into a single hierarchy, which allows users (and applications) to access data simply by knowing its location within that hierarchy.
			</div><div class="para"><p></p>
				The starting point of this hierarchical tree is called the root, <code class="filename">/</code>. This directory can contain named subdirectories. For instance, the <code class="literal">home</code> subdirectory of <code class="filename">/</code> is called <code class="filename">/home/</code>. This subdirectory can, in turn, contain other subdirectories, and so on. Each directory can also contain files, where the actual data will be stored. Thus, the <code class="filename">/home/rmas/Desktop/hello.txt</code> name refers to a file named <code class="literal">hello.txt</code> stored in the <code class="literal">Desktop</code> subdirectory of the <code class="literal">rmas</code> subdirectory of the <code class="literal">home</code> directory present in the root. The kernel translates between this naming system and the actual, physical storage on a disk.
			</div><div class="para"><p></p>
				Unlike other systems, there's only one such hierarchy, and it can integrate data from several disks. One of these disks is used as the root, and the others are “mounted” on directories in the hierarchy (the Unix command is called <code class="command">mount</code>); these other disks are then available under these “mount points”. This allows storing users' home directories (traditionally stored within <code class="filename">/home/</code>) on a second hard disk, which will contain <code class="literal">rhertzog</code> and <code class="literal">rmas</code> directories. Once the disk is mounted on <code class="filename">/home/</code>, these directories become accessible at their usual locations, and paths such as <code class="filename">/home/rmas/Desktop/hello.txt</code> keep working.
			</div><a id="idp14458056" class="indexterm"></a><div class="para"><p></p>
				There are many filesystems, corresponding to many ways of physically storing data on disks. The most widely known are <span class="emphasis"><em>ext2</em></span>, <span class="emphasis"><em>ext3</em></span> and <span class="emphasis"><em>ext4</em></span>, but others exist. For instance, <span class="emphasis"><em>vfat</em></span> is the system that was historically used by DOS and Windows operating systems, which allows using hard disks under Debian as well as under Windows. In any case, a filesystem must be prepared on a disk before it can be mounted and this operation is known as “formatting”. Commands such as <code class="command">mkfs.ext3</code> (where <code class="command">mkfs</code> stands for <span class="emphasis"><em>MaKe FileSystem</em></span>) handle formatting. These commands require, as a parameter, a device file representing the partition to be formatted (for instance, <code class="filename">/dev/sda1</code>). This operation is destructive and should only be run once, except if one deliberately wishes to wipe a filesystem and start afresh.
			</div><div class="para"><p></p>
				There are even network filesystems, such as <acronym class="acronym">NFS</acronym>, where data is not stored on a local disk. Instead, data is transmitted through the network to a server that stores and retrieves them on demand. The filesystem abstraction shields users from having to care: files remain accessible in their usual hierarchical way.
			</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title" id="section.fonctions-partagees">B.4.3. Shared Functions</h3></div></div></div><div class="para"><p></p>
				Since a number of the same functions are used by all software, it makes sense to centralize them in the kernel. For instance, shared filesystem handling allow any application to simply open a file by name, without needing to worry where the file is stored physically. The file can be stored in several different slices on a hard disk, or split across several hard disks, or even stored on a remote file server. Shared communication functions, are used by applications to exchange data independently of the way the data is transported. For instance, transport could be over any combination of local or wireless networks, or over a telephone landline.
			</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title" id="section.gestion-processus">B.4.4. Managing Processes</h3></div></div></div><a id="idp14464256" class="indexterm"></a><div class="para"><p></p>
				A process is a running instance of a program. This requires memory to store both the program itself and its operating data. The kernel is in charge of creating and tracking them. When a program runs, first the kernel sets aside memory, then loads the executable code from the filesystem into it, and then starts the code running. It keeps information about this process, the most visible of which, is an identification number known as <span class="emphasis"><em>pid</em></span> (<span class="emphasis"><em>process identifier</em></span>).
			</div><div class="para"><p></p>
				Unix-like kernels (including Linux), and like most other modern operating systems, are able of “multi-tasking”. In other words, they allow running many processes “at the same time”. There's actually only one running process at any one time, but the kernel cuts time into small slices and runs each process in turn. Since these time slices are very short (in the millisecond range), they create the illusion of processes running in parallel, although they're actually only active during some time intervals and idle the rest of the time. The kernel's job is to adjust its scheduling mechanisms to keep that illusion, while maximizing the global system performance. If the time slices are too long, the application may lack in snappiness and user interactivity. Too short, and the system loses time switching tasks too frequently. These decisions can be tweaked with process priorities. High-priority processes will run for longer and more frequent time slices than low-priority processes.
			</div><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>NOTE</em></span> Multi-processor systems (and variants)</h6></div></div></div><div class="para"><p></p>
				The restriction described here is only a corner case. The actual restriction is that there can only be one running process <span class="emphasis"><em>per processor core</em></span> at a time. Multi-processor, multi-core or “hyper-threaded” systems allow several processes to run in parallel. The same time-slicing system is still used, though, so as to handle cases where there are more active processes than available processor cores. This is the usual case: a basic system, even a mostly idle one, almost always has tens of running processes.
			</div></div><div class="para"><p></p>
				Of course, the kernel allows running several independent instances of the same program. But each can only access its own time slices and memory. Their data thus remain independent.
			</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title" id="section.permissions">B.4.5. Rights Management</h3></div></div></div><div class="para"><p></p>
				Unix-like systems are also multi-user. They provide a rights management system that allows separate groups and users, and for choosing to permit or block actions based on permissions. The kernel manages, for each process, data allowing permission checking. Most of the time, this means the process' “identity” is the same as the user that started it. And, the process is only able to take user permitted actions. For instance, trying to open a file requires the kernel to check the process identity against access permissions (for more details on this particular example, see <a class="xref" href="sect.rights-management.html">Section 9.3, “Managing Rights”</a>).
			</div></div></div><div id="site_footer"></div><script type="text/javascript">
		$("#site_footer").load("../../../../../footer.html");
	</script><ul class="docnav"><li class="previous"><a accesskey="p" href="sect.computer-layers.html"><strong>Prev</strong>B.3. Inner Workings of a Computer: the Different ...</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="sect.user-space.html"><strong>Next</strong>B.5. The User Space</a></li></ul></body></html>
