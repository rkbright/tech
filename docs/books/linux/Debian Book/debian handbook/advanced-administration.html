<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 12. Advanced Administration</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="generator" content="publican 3.0" /><meta name="package" content="Debian-debian-handbook-6.0-en-US-1.0-1" /><meta name="keywords" content="RAID, LVM, FAI, Preseeding, Monitoring, Virtualization, Xen, LXC" /><link rel="home" href="index.html" title="The Debian Administrator's Handbook" /><link rel="up" href="index.html" title="The Debian Administrator's Handbook" /><link rel="prev" href="sect.ldap-directory.html" title="11.7. LDAP Directory" /><link rel="next" href="sect.virtualization.html" title="12.2. Virtualization" /></head><body><p class="hidden" id="title"><a class="left" href="http://www.debian.org"><img src="Common_Content/images/image_left.png" alt="Product Site" /></a><a class="right" href="http://debian-handbook.info"><img src="Common_Content/images/image_right.png" alt="Documentation Site" /></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="sect.ldap-directory.html"><strong>Prev</strong></a></li><li class="home">The Debian Administrator's Handbook</li><li class="next"><a accesskey="n" href="sect.virtualization.html"><strong>Next</strong></a></li></ul><div class="chapter" id="advanced-administration"><div class="titlepage"><div><div><h2 class="title">Chapter 12. Advanced Administration</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="advanced-administration.html#sect.raid-and-lvm">12.1. RAID and LVM</a></span></dt><dd><dl><dt><span class="section"><a href="advanced-administration.html#section.raid-soft">12.1.1. Software RAID</a></span></dt><dt><span class="section"><a href="advanced-administration.html#section.lvm">12.1.2. LVM</a></span></dt><dt><span class="section"><a href="advanced-administration.html#raid-ou-lvm">12.1.3. RAID or LVM?</a></span></dt></dl></dd><dt><span class="section"><a href="sect.virtualization.html">12.2. Virtualization</a></span></dt><dd><dl><dt><span class="section"><a href="sect.virtualization.html#xen">12.2.1. Xen</a></span></dt><dt><span class="section"><a href="sect.virtualization.html#lxc">12.2.2. LXC</a></span></dt><dt><span class="section"><a href="sect.virtualization.html#idp11279352">12.2.3. Virtualization with KVM</a></span></dt></dl></dd><dt><span class="section"><a href="sect.automated-installation.html">12.3. Automated Installation</a></span></dt><dd><dl><dt><span class="section"><a href="sect.automated-installation.html#fai">12.3.1. Fully Automatic Installer (FAI)</a></span></dt><dt><span class="section"><a href="sect.automated-installation.html#d-i-preseeding">12.3.2. Preseeding Debian-Installer</a></span></dt><dt><span class="section"><a href="sect.automated-installation.html#idp11596320">12.3.3. Simple-CDD: The All-In-One Solution</a></span></dt></dl></dd><dt><span class="section"><a href="sect.monitoring.html">12.4. Monitoring</a></span></dt><dd><dl><dt><span class="section"><a href="sect.monitoring.html#section.munin">12.4.1. Setting Up Munin</a></span></dt><dt><span class="section"><a href="sect.monitoring.html#section.nagios">12.4.2. Setting Up Nagios</a></span></dt></dl></dd></dl></div><div class="highlights"><div class="para"><p></p>
		This chapter revisits some aspects we already described, with a different perspective: instead of installing one single computer, we will study mass-deployment systems; instead of creating RAID or LVM volumes at install time, we'll learn to do it by hand so we can later revise our initial choices. Finally, we will discuss monitoring tools and virtualization techniques. As a consequence, this chapter is more particularly targeting professional administrators, and focuses somewhat less on individuals responsible for their home network.
	</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="sect.raid-and-lvm">12.1. RAID and LVM</h2></div></div></div><div class="para"><p></p>
			<a class="xref" href="installation.html">Chapter 4, <em>Installation</em></a> presented these technologies from the point of view of the installer, and how it integrated them to make their deployment easy from the start. After the initial installation, an administrator must be able to handle evolving storage space needs without having to resort to an expensive reinstallation. They must therefore master the required tools for manipulating RAID and LVM volumes.
		</div><div class="para"><p></p>
			RAID and LVM are both techniques to abstract the mounted volumes from their physical counterparts (actual hard-disk drives or partitions thereof); the former secures the data by introducing redundancy, the latter makes data management more flexible and independent of the actual size of the underlying disks. In both cases, the system ends up with new block devices, which can be used to create filesystems or swap space, without necessarily having them mapped to one physical disk. RAID and LVM come from quite different backgrounds, but their functionality can overlap somewhat, which is why they are ofter mentioned together.
		</div><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>PERSPECTIVE</em></span> Btrfs combines LVM and RAID</h6></div></div></div><div class="para"><p></p>
			While LVM and RAID are two distinct kernel subsystems that come between the disk block devices and their filesystems, <span class="emphasis"><em>btrfs</em></span> is a new filesystem, initially developed at Oracle, that purports to combine the featuresets of LVM and RAID and much more. It is mostly functional, although still tagged “experimental” because its development is incomplete (some features aren't implemented yet). <div xmlns="" class="url">→ <a xmlns="http://www.w3.org/1999/xhtml" href="http://btrfs.wiki.kernel.org/">http://btrfs.wiki.kernel.org/</a></div>
		</div><div class="para"><p></p>
			Among the noteworthy features are the ability to take a snapshot of a filesystem tree at any point in time. This snapshot copy doesn't initially use any disk space, the data only being duplicated when one of the copies is modified. The filesystem also handles transparent compression of files, and checksums ensure the integrity of all stored data.
		</div></div><div class="para"><p></p>
			In both the RAID and LVM cases, the kernel provides a block device file, similar to the ones corresponding to a hard disk drive or a partition. When an application, or another part of the kernel, requires access to a block of such a device, the appropriate subsystem routes the block to the relevant physical layer. Depending on the configuration, this block can be stored on one or several physical disks, and its physical location may not be directly correlated to the location of the block in the logical device.
		</div><div class="section"><div class="titlepage"><div><div><h3 class="title" id="section.raid-soft">12.1.1. Software RAID</h3></div></div></div><div class="para"><p></p>
				RAID 
				<a id="idp6727024" class="indexterm"></a>
				 means <span class="emphasis"><em>Redundant Array of Independent Disks</em></span>. The goal of this system is to prevent data loss in case of hard disk failure. The general principle is quite simple: data are stored on several physical disks instead of only one, with a configurable level of redundancy. Depending on this amount of redundancy, and even in the event of an unexpected disk failure, data can be losslessly reconstructed from the remaining disks.
			</div><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>CULTURE</em></span> <span class="foreignphrase"><em class="foreignphrase">Independent</em></span> or <span class="foreignphrase"><em class="foreignphrase">inexpensive</em></span>?</h6></div></div></div><div class="para"><p></p>
				The I in RAID initially stood for <span class="emphasis"><em>inexpensive</em></span>, because RAID allowed a drastic increase in data safety without requiring investing in expensive high-end disks. Probably due to image concerns, however, it's now more customarily considered to stand for <span class="emphasis"><em>independent</em></span>, which doesn't have the unsavoury flavour of cheapness.
			</div></div><div class="para"><p></p>
				RAID can be implemented either by dedicated hardware (RAID modules integrated into SCSI or SATA controller cards) or by software abstraction (the kernel). Whether hardware or software, a RAID system with enough redundancy can transparently stay operational when a disk fails; the upper layers of the stack (applications) can even keep accessing the data in spite of the failure. Of course, this “degraded mode” can have an impact on performance, and redundancy is reduced, so a further disk failure can lead to data loss. In practice, therefore, one will strive to only stay in this degraded mode for as long as it takes to replace the failed disk. Once the new disk is in place, the RAID system can reconstruct the required data so as to return to a safe mode. The applications won't notice anything, apart from potentially reduced access speed, while the array is in degraded mode or during the reconstruction phase.
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title" id="niveaux-de-raid">12.1.1.1. Different RAID Levels</h4></div></div></div><div class="para"><p></p>
					RAID has actually several levels, differenciated by their layout and the amount of redundancy they provide. The more redundant, the more failure-proof, since the system will be able to keep working with more failed disks. The counterpart is that the usable space shrinks; seen the other way, more disks will be needed to store the same amount of data.
				</div><div class="variablelist"><dl><dt class="varlistentry"><span class="term">Linear RAID</span></dt><dd><div class="para"><p></p>
								Even though the kernel's RAID subsystem allows creating “linear RAID”, this is not proper RAID, since this setup doesn't involve any redundancy. The kernel merely aggregates several disks end-to-end and provides the resulting aggregated volume as one virtual disk (one block device). That's about its only function. This setup is rarely used by itself (see later for the exceptions), especially since the lack of redundancy means that one disk failing makes the whole aggregate, and therefore all the data, unavailable.
							</div></dd><dt class="varlistentry"><span class="term">RAID-0</span></dt><dd><div class="para"><p></p>
								This level doesn't provide any redundancy either, but disks aren't simply stuck on end one after another: they are divided in <span class="emphasis"><em>stripes</em></span>, and the blocks on the virtual device are stored on stripes on alternating physical disks. In a two-disk RAID-0 setup, for instance, even-numbered blocks of the virtual device will be stored on the first physical disk, while odd-numbered blocks will end up on the second physical disk.
							</div><div class="para"><p></p>
								This system doesn't aim at increasing reliability, since (as in the linear case) the availability of all the data is jeopardized as soon as one disk fails, but at increasing performance: during sequential access to large amounts of contiguous data, the kernel will be able to read from both disks (or write to them) in parallel, which increases the data transfer rate. However, RAID-0 use is shrinking, its niche being filled by LVM (see later).
							</div></dd><dt class="varlistentry"><span class="term">RAID-1</span></dt><dd><div class="para"><p></p>
								This level, also known as “RAID mirroring”, is both the simplest and the most widely used setup. In its standard form, it uses two physical disks of the same size, and provides a logical volume of the same size again. Data are stored identically on both disks, hence the “mirror” nickname. When one disk fails, the data is still available on the other. For really critical data, RAID-1 can of course be set up on more than two disks, with a direct impact on the ratio of hardware cost versus available payload space.
							</div><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>NOTE</em></span> Disks and cluster sizes</h6></div></div></div><div class="para"><p></p>
								If two disks of different sizes are set up in a mirror, the bigger one will not be fully used, since it will contain the same data as the smallest one and nothing more. The useful available space provided by a RAID-1 volume therefore matches the size of the smallest disk in the array. This still holds for RAID volumes with a higher RAID level, even though redundancy is stored differently.
							</div><div class="para"><p></p>
								It is therefore important, when setting up RAID arrays (except for RAID-0 and “linear RAID”), to only assemble disks of identical, or very close, sizes, to avoid wasting resources.
							</div></div><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>NOTE</em></span> Spare disks</h6></div></div></div><div class="para"><p></p>
								RAID levels that include redundancy allow assigning more disks than required to an array. The extra disks are used as spares when one of the main disks fails. For instance, in a mirror of two disks plus one spare, if one of the first two disks fails, the kernel will automatically (and immediately) reconstruct the mirror using the spare disk, so that redundancy stays assured after the reconstruction time. This can be used as another kind of safeguard for critical data.
							</div><div class="para"><p></p>
								One would be forgiven for wondering how this is better than simply mirroring on three disks to start with. The advantage of the “spare disk” configuration is that the spare disk can be shared across several RAID volumes. For instance, one can have three mirrored volumes, with redundancy assured even in the event of one disk failure, with only seven disks (three pairs, plus one shared spare), instead of the nine disks that would be required by three triplets.
							</div></div><div class="para"><p></p>
								This RAID level, although expensive (since only half of the physical storage space, at best, is useful), is widely used in practice. It is simple to understand, and it allows very simple backups: since both disks have identical contents, one of them can be temporarily extracted with no impact on the working system. Read performance is often increased since the kernel can read half of the data on each disk in parallel, while write performance isn't too severely degraded. In case of a RAID-1 array of N disks, the data stays available even with N-1 disk failures.
							</div></dd><dt class="varlistentry"><span class="term">RAID-4</span></dt><dd><div class="para"><p></p>
								This RAID level, not widely used, uses N disks to store useful data, and an extra disk to store redundancy information. If that disk fails, the system can reconstruct its contents from the other N. If one of the N data disks fails, the remaining N-1 combined with the “parity” disk contain enough information to reconstruct the required data.
							</div><div class="para"><p></p>
								RAID-4 isn't too expensive since it only involves a one-in-N increase in costs and has no noticeable impact on read performance, but writes are slowed down. Furthermore, since a write to any of the N disks also involves a write to the parity disk, the latter sees many more writes than the former, and its lifespan can shorten dramatically as a consequence. Data on a RAID-4 array is safe only up to one failed disk (of the N+1).
							</div></dd><dt class="varlistentry"><span class="term">RAID-5</span></dt><dd><div class="para"><p></p>
								RAID-5 addresses the asymmetry issue of RAID-4: parity blocks are spread over all of the N+1 disks, with no single disk having a particular role.
							</div><div class="para"><p></p>
								Read and write performance are identical to RAID-4. Here again, the system stays functional with up to one failed disk (of the N+1), but no more.
							</div></dd><dt class="varlistentry"><span class="term">RAID-6</span></dt><dd><div class="para"><p></p>
								RAID-6 can be considered an extension of RAID-5, where each series of N blocks involves two redundancy blocks, and each such series of N+2 blocks is spread over N+2 disks.
							</div><div class="para"><p></p>
								This RAID level is slightly more expensive than the previous two, but it brings some extra safety since up to two drives (of the N+2) can fail without compromising data availability. The counterpart is that write operations now involve writing one data block and two redundancy blocks, which makes them even slower.
							</div></dd><dt class="varlistentry"><span class="term">RAID-1+0</span></dt><dd><div class="para"><p></p>
								This isn't stricly speaking, a RAID level, but a stacking of two RAID groupings. Starting from 2×N disks, one first sets them up by pairs into N RAID-1 volumes; these N volumes are then aggregated into one, either by “linear RAID” or (increasingly) by LVM. This last case goes farther than pure RAID, but there's no problem with that.
							</div><div class="para"><p></p>
								RAID-1+0 can survive multiple disk failures: up to N in the 2×N array described above, provided that at least one disk keeps working in each of the RAID-1 pairs.
							</div><div class="sidebar"><a xmlns="" id="cadre.raid-10"></a><div class="titlepage"><div><div><h6><span class="emphasis"><em>GOING FURTHER</em></span> RAID-10</h6></div></div></div><div class="para"><p></p>
								RAID-10 is generally considered a synonym of RAID-1+0, but a Linux specificity makes it actually a generalization. This setup allows a system where each block is stored on two different disks, even with an odd number of disks, the copies being spread out along a configurable model.
							</div><div class="para"><p></p>
								Performances will vary depending on the chosen repartition model and redundancy level, and of the workload of the logical volume.
							</div></div></dd></dl></div><div class="para"><p></p>
					Obviously, the RAID level will be chosen according to the constraints and requirements of each application. Note that a single computer can have several distinct RAID arrays with different configurations.
				</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title" id="mise-en-place-du-raid">12.1.1.2. Setting up RAID</h4></div></div></div><div class="para"><p></p>
					Setting up RAID volumes requires the <span class="pkg pkg">mdadm</span> <a id="idp9478976" class="indexterm"></a>
					 package; it provides the <code class="command">mdadm</code> command, which allows creating and manipulating RAID arrays, as well as scripts and tools integrating it to the rest of the system, including the monitoring system.
				</div><div class="para"><p></p>
					Our example will be a server with a number of disks, some of which are already used, the rest being available to setup RAID. We initially have the following disks and partitions:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para"><p></p>
							the <code class="filename">sda</code> disk, 4 GB, is entirely available;
						</div></li><li class="listitem"><div class="para"><p></p>
							the <code class="filename">sde</code> disk, 4 GB, is also entirely available;
						</div></li><li class="listitem"><div class="para"><p></p>
							on the <code class="filename">sdg</code> disk, only partition <code class="filename">sdg2</code> (about 4 GB) is available;
						</div></li><li class="listitem"><div class="para"><p></p>
							finally, a <code class="filename">sdh</code> disk, still 4 GB, entirely available.
						</div></li></ul></div><div class="para"><p></p>
					We're going to use these physical elements to build two volumes, one RAID-0 and one mirror (RAID-1). Let's start with the RAID-0 volume:
				</div><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>NOTE</em></span> Identifying existing RAID volumes</h6></div></div></div><div class="para"><p></p>
					The <code class="filename">/proc/mdstat</code> file lists existing volumes and their states. When creating a new RAID volume, care should be taken not to name it the same as an existing volume.
				</div></div><pre class="screen"><code class="computeroutput"># </code><strong class="userinput"><code>mdadm --create /dev/md0 --level=0 --raid-devices=2 /dev/sda /dev/sde</code></strong>
<code class="computeroutput">mdadm: Defaulting to version 1.2 metadata
mdadm: array /dev/md0 started.
# </code><strong class="userinput"><code>mdadm --query /dev/md0</code></strong>
<code class="computeroutput">/dev/md0: 8.00GiB raid0 2 devices, 0 spares. Use mdadm --detail for more detail.
# </code><strong class="userinput"><code>mdadm --detail /dev/md0</code></strong>
<code class="computeroutput">/dev/md0:
        Version : 1.2
  Creation Time : Thu Sep 30 15:21:15 2010
     Raid Level : raid0
     Array Size : 8388480 (8.00 GiB 8.59 GB)
   Raid Devices : 2
  Total Devices : 2
    Persistence : Superblock is persistent

    Update Time : Thu Sep 30 15:21:15 2010
          State : active
 Active Devices : 2
Working Devices : 2
 Failed Devices : 0
  Spare Devices : 0

     Chunk Size : 512K

           Name : squeeze:0  (local to host squeeze)
           UUID : 0012a273:cbdb8b83:0ee15f7f:aec5e3c3
         Events : 0

    Number   Major   Minor   RaidDevice State
       0       8        0        0      active sync   /dev/sda
       1       8       64        1      active sync   /dev/sde
# </code><strong class="userinput"><code>mkfs.ext4 /dev/md0</code></strong>
<code class="computeroutput">
mke2fs 1.41.12 (17-May-2010)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
524288 inodes, 2097152 blocks
104857 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=2147483648
55 block groups
32768 blocks per group, 32768 fragments per group
8160 inodes per group
Superblock backups stored on blocks: 
        32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632

Writing inode tables: done
Creating journal (32768 blocks): done
Writing superblocks and filesystem accounting information: done

This filesystem will be automatically checked every 26 mounts or
180 days, whichever comes first.  Use tune2fs -c or -i to override.
# </code><strong class="userinput"><code>mkdir /srv/raid-0</code></strong>
<code class="computeroutput"># </code><strong class="userinput"><code>mount /dev/md0 /srv/raid-0</code></strong>
<code class="computeroutput"># </code><strong class="userinput"><code>df -h /srv/raid-0</code></strong>
<code class="computeroutput">Filesystem            Size  Used Avail Use% Mounted on
/dev/md0              8.0G  249M  7.4G   4% /srv/raid-0</code></pre><div class="para"><p></p>
					The <code class="command">mdadm --create</code> command requires several parameters: the name of the volume to create (<code class="filename">/dev/md*</code>, with MD standing for <span class="foreignphrase"><em class="foreignphrase">Multiple Device</em></span>), the RAID level, the number of disks (which is compulsory despite being mostly meaningful only with RAID-1 and above), and the physical drives to use. Once the device is created, we can use it like we'd use a normal partition, create a filesystem on it, mount that filesystem, and so on. Note that our creation of a RAID-0 volume on <code class="filename">md0</code> is nothing but coincidence, and the numbering of the array doesn't need to be correlated to the chosen amount of redundancy.
				</div><div class="para"><p></p>
					Creation of a RAID-1 follows a similar fashion, the differences only being noticeable after the creation:
				</div><pre class="screen"><code class="computeroutput"># </code><strong class="userinput"><code>mdadm --create /dev/md1 --level=1 --raid-devices=2 /dev/sdg2 /dev/sdh</code></strong>
<code class="computeroutput">mdadm: largest drive (/dev/sdg2) exceed size (4194240K) by more than 1%
Continue creating array? </code><strong class="userinput"><code>y</code></strong>
<code class="computeroutput">mdadm: array /dev/md1 started.
# </code><strong class="userinput"><code>mdadm --query /dev/md1</code></strong>
<code class="computeroutput">/dev/md1: 4.00GiB raid1 2 devices, 0 spares. Use mdadm --detail for more detail.
# </code><strong class="userinput"><code>mdadm --detail /dev/md1</code></strong>
<code class="computeroutput">/dev/md1:
        Version : 1.2
  Creation Time : Thu Sep 30 15:39:13 2010
     Raid Level : raid1
     Array Size : 4194240 (4.00 GiB 4.29 GB)
  Used Dev Size : 4194240 (4.00 GiB 4.29 GB)
   Raid Devices : 2
  Total Devices : 2
    Persistence : Superblock is persistent

    Update Time : Thu Sep 30 15:39:26 2010
          State : active, resyncing
 Active Devices : 2
Working Devices : 2
 Failed Devices : 0
  Spare Devices : 0

 Rebuild Status : 10% complete

           Name : squeeze:1  (local to host squeeze)
           UUID : 20a8419b:41612750:b9171cfe:00d9a432
         Events : 27

    Number   Major   Minor   RaidDevice State
       0       8       98        0      active sync   /dev/sdg2
       1       8      112        1      active sync   /dev/sdh
# </code><strong class="userinput"><code>mdadm --detail /dev/md1</code></strong>
<code class="computeroutput">/dev/md1:
[...]
          State : active
[...]
</code></pre><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>TIP</em></span> RAID, disks and partitions</h6></div></div></div><div class="para"><p></p>
					As illustrated by our example, RAID devices can be constructed out of disk partitions, and do not require full disks.
				</div></div><div class="para"><p></p>
					A few remarks are in order. First, <code class="command">mdadm</code> notices that the physical elements have different sizes; since this implies that some space will be lost on the bigger element, a confirmation is required.
				</div><div class="para"><p></p>
					More importantly, note the state of the mirror. The normal state of a RAID mirror is that both disks have exactly the same contents. However, nothing guarantees this is the case when the volume is first created. The RAID subsystem will therefore provide that guarantee itself, and there will be a synchronisation phase as soon as the RAID device is created. After some time (the exact amount will depend on the actual size of the disks…), the RAID array switches to the “active” state. Note that during this reconstruction phase, the mirror is in a degraded mode, and redundancy isn't assured. A disk failing during that risk window could lead to losing all the data. Large amounts of critical data, however, are rarely stored on a freshly created RAID array before its initial synchronisation. Note that even in degraded mode, the <code class="filename">/dev/md1</code> is usable, and a filesystem can be created on it, as well as some data copied on it.
				</div><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>TIP</em></span> Starting a mirror in degraded mode</h6></div></div></div><div class="para"><p></p>
					Sometimes two disks are not immediately available when one wants to start a RAID-1 mirror, for instance because one of the disks one plans to include is already used to store the data one wants to move to the array. In such circumstances, it is possible to deliberately create a degraded RAID-1 array by passing <code class="filename">missing</code> instead of a device file as one of the arguments to <code class="command">mdadm</code>. Once the data have been copied to the “mirror”, the old disk can be added to the array. A synchronisation will then take place, giving us the redundancy that was wanted in the first place.
				</div></div><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>TIP</em></span> Setting up a mirror without synchronisation</h6></div></div></div><div class="para"><p></p>
					RAID-1 volumes are often created to be used as a new disk, often considered blank. The actual initial contents of the disk is therefore not very relevant, since one only needs to know that the data written after the creation of the volume, in particular the filesystem, can be accessed later.
				</div><div class="para"><p></p>
					One might therefore wonder about the point of synchronising both disks at creation time. Why care whether the contents are identical on zones of the volume that we know will only be read after we have written to them?
				</div><div class="para"><p></p>
					Fortunately, this synchronisation phase can be avoided by passing the <code class="literal">--assume-clean</code> option to <code class="command">mdadm</code>. However, this option can lead to surprises in cases where the initial data will be read (for instance if a filesystem is already present on the physical disks), which is why it isn't enabled by default.
				</div></div><div class="para"><p></p>
					Now let's see what happens when one of the elements of the RAID-1 array fails. <code class="command">mdadm</code>, in particular its <code class="literal">--fail</code> option, allows simulating such a disk failure:
				</div><pre class="screen"><code class="computeroutput"># </code><strong class="userinput"><code>mdadm /dev/md1 --fail /dev/sdh</code></strong>
<code class="computeroutput">mdadm: set /dev/sdh faulty in /dev/md1
# </code><strong class="userinput"><code>mdadm --detail /dev/md1</code></strong>
<code class="computeroutput">/dev/md1:
[...]
    Update Time : Thu Sep 30 15:45:50 2010
          State : active, degraded
 Active Devices : 1
Working Devices : 1
 Failed Devices : 1
  Spare Devices : 0

           Name : squeeze:1  (local to host squeeze)
           UUID : 20a8419b:41612750:b9171cfe:00d9a432
         Events : 35

    Number   Major   Minor   RaidDevice State
       0       8       98        0      active sync   /dev/sdg2
       1       0        0        1      removed

       2       8      112        -      faulty spare  /dev/sdh</code></pre><div class="para"><p></p>
					The contents of the volume are still accessible (and, if it's mounted, the applications don't notice a thing), but the data safety isn't assured anymore: should the <code class="filename">sdg</code> disk fail in turn, the data would be lost. We want to avoid that risk, so we'll replace the failed disk with a new one, <code class="filename">sdi</code>:
				</div><pre class="screen"><code class="computeroutput"># </code><strong class="userinput"><code>mdadm /dev/md1 --add /dev/sdi</code></strong>
<code class="computeroutput">mdadm: added /dev/sdi
# </code><strong class="userinput"><code>mdadm --detail /dev/md1</code></strong>
<code class="computeroutput">/dev/md1:
[...]
   Raid Devices : 2
  Total Devices : 3
    Persistence : Superblock is persistent

    Update Time : Thu Sep 30 15:52:29 2010
          State : active, degraded, recovering
 Active Devices : 1
Working Devices : 2
 Failed Devices : 1
  Spare Devices : 1

 Rebuild Status : 45% complete

           Name : squeeze:1  (local to host squeeze)
           UUID : 20a8419b:41612750:b9171cfe:00d9a432
         Events : 53

    Number   Major   Minor   RaidDevice State
       0       8       98        0      active sync   /dev/sdg2
       3       8      128        1      spare rebuilding   /dev/sdi

       2       8      112        -      faulty spare   /dev/sdh
# </code><strong class="userinput"><code>[...]</code></strong>
<code class="computeroutput">[...]
# </code><strong class="userinput"><code>mdadm --detail /dev/md1</code></strong>
<code class="computeroutput">/dev/md1:
[...]
    Update Time : Thu Sep 30 15:52:35 2010
          State : active
 Active Devices : 2
Working Devices : 2
 Failed Devices : 1
  Spare Devices : 0

           Name : squeeze:1  (local to host squeeze)
           UUID : 20a8419b:41612750:b9171cfe:00d9a432
         Events : 71

    Number   Major   Minor   RaidDevice State
       0       8       98        0      active sync   /dev/sdg2
       1       8      128        1      active sync   /dev/sdi

       2       8      112        -      faulty spare   /dev/sdh</code></pre><div class="para"><p></p>
					Here again, the kernel automatically triggers a reconstruction phase during which the volume, although still accessible, is in a degraded mode. Once the reconstruction is over, the RAID array is back to a normal state. One can then tell the system that the <code class="filename">sdh</code> disk is about to be removed from the array, so as to end up with a classical RAID mirror on two disks:
				</div><pre class="screen"><code class="computeroutput"># </code><strong class="userinput"><code>mdadm /dev/md1 --remove /dev/sdh</code></strong>
<code class="computeroutput">mdadm: hot removed /dev/sdh from /dev/md1
# </code><strong class="userinput"><code>mdadm --detail /dev/md1</code></strong>
<code class="computeroutput">/dev/md1:
[...]
    Number   Major   Minor   RaidDevice State
       0       8       98        0      active sync   /dev/sdg2
       1       8      128        1      active sync   /dev/sdi</code></pre><div class="para"><p></p>
					From then on, the drive can be physically removed when the server is next switched off, or even hot-removed when the hardware configuration allows hot-swap. Such configurations include some SCSI controllers, most SATA disks, and external drives operating on USB or Firewire.
				</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title" id="sauvegarde-config-raid">12.1.1.3. Backing up the Configuration</h4></div></div></div><div class="para"><p></p>
					Most of the meta-data concerning RAID volumes are saved directly on the disks that make up these arrays, so that the kernel can detect the arrays and their components and assemble them automatically when the system starts up. However, backing up this configuration is encouraged, because this detection isn't fail-proof, and it's only expected that it will fail precisely in sensitive circumstances. In our example, if the <code class="filename">sdh</code> disk failure had been real (instead of simulated) and the system had been restarted without removing this <code class="filename">sdh</code> disk, this disk could start working again due to having been probed during the reboot. The kernel would then have three physical elements, each claiming to contain half of the same RAID volume. Another source of confusion can come when RAID volumes from two servers are consolidated onto one server only. If these arrays were running normally before the disks were moved, the kernel would be able to detect and reassemble the pairs properly; but if the moved disks had been aggregated into an <code class="filename">md1</code> on the old server, and the new server already has an <code class="filename">md1</code>, one of the mirrors would be renamed.
				</div><div class="para"><p></p>
					Backing up the configuration is therefore important, if only for reference. The standard way to do it is by editing the <code class="filename">/etc/mdadm/mdadm.conf</code> file, an example of which is listed here:
				</div><div class="example"><h6>Example 12.1. <code class="command">mdadm</code> configuration file</h6><div class="example-contents"><pre class="programlisting"># mdadm.conf
#
# Please refer to mdadm.conf(5) for information about this file.
#

# by default, scan all partitions (/proc/partitions) for MD superblocks.
# alternatively, specify devices to scan, using wildcards if desired.
DEVICE /dev/sd*

# auto-create devices with Debian standard permissions
CREATE owner=root group=disk mode=0660 auto=yes

# automatically tag new arrays as belonging to the local system
HOMEHOST &lt;system&gt;

# instruct the monitoring daemon where to send mail alerts
MAILADDR root

ARRAY /dev/md0 metadata=1.2 name=squeeze:0 UUID=6194b63f:69a40eb5:a79b7ad3:c91f20ee
ARRAY /dev/md1 metadata=1.2 name=squeeze:1 UUID=20a8419b:41612750:b9171cfe:00d9a432
</pre></div></div><br class="example-break" /><div class="para"><p></p>
					One of the most useful details is the <code class="literal">DEVICE</code> option, which lists the devices where the system will automatically look for components of RAID volumes at start-up time. In our example, we replaced the default value, <code class="literal">partitions</code>, with an explicit list of device files, since we chose to use entire disks and not only partitions, for some volumes.
				</div><div class="para"><p></p>
					The last two lines in our example are those allowing the kernel to safely pick which volume number to assign to which array. The metadata stored on the disks themselves are enough to re-assemble the volumes, but not to determine the volume number (and the matching <code class="filename">/dev/md*</code> device name).
				</div><div class="para"><p></p>
					Fortunately, these lines can be generated automatically:
				</div><pre class="screen"><code class="computeroutput"># </code><strong class="userinput"><code>mdadm --misc --detail --brief /dev/md?</code></strong>
<code class="computeroutput">ARRAY /dev/md0 metadata=1.2 name=squeeze:0 UUID=6194b63f:69a40eb5:a79b7ad3:c91f20ee
ARRAY /dev/md1 metadata=1.2 name=squeeze:1 UUID=20a8419b:41612750:b9171cfe:00d9a432</code></pre><div class="para"><p></p>
					The contents of these last two lines doesn't depend on the list of disks included in the volume. It is therefore not necessary to regenerate these lines when replacing a failed disk with a new one. On the other hand, care must be taken to update the file when creating or deleting a RAID array.
				</div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title" id="section.lvm">12.1.2. LVM</h3></div></div></div><div class="para"><p></p>
				<a id="idp10028488" class="indexterm"></a>
				 LVM, the <span class="emphasis"><em>Logical Volume Manager</em></span>, is another approach to abstracting logical volumes from their physical supports, which focuses on increasing flexibility rather than increasing reliability. LVM allows changing a logical volume transparently as far as the applications are concerned; for instance, it is possible to add new disks, migrate the data to them, and remove the old disks, without unmounting the volume.
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title" id="lvm-concepts">12.1.2.1. LVM Concepts</h4></div></div></div><div class="para"><p></p>
					This flexibility is attained by a level of abstraction involving three concepts.
				</div><div class="para"><p></p>
					First, the PV (<span class="emphasis"><em>Physical Volume</em></span>) is the entity closest to the hardware: it can be partitions on a disk, or a full disk, or even any other block device. Note that when a physical element is set up to be a PV for LVM, it should only be accessed via LVM, otherwise the system will get confused.
				</div><div class="para"><p></p>
					A number of PVs can be clustered in a VG (<span class="emphasis"><em>Volume Group</em></span>), which can be compared to disks both virtual and extensible. VGs are abstract, and don't appear in a device file in the <code class="filename">/dev</code> hierarchy, so there's no risk of using them directly.
				</div><div class="para"><p></p>
					The third kind of object is the LV (<span class="emphasis"><em>Logical Volume</em></span>), which is a chunk of a VG; if we keep the VG-as-disk analogy, the LV compares to a partition. The LV appear as block device with an entry in <code class="filename">/dev</code>, and it can be used as any other physical partition can be (most commonly, to host a filesystem or swap space).
				</div><div class="para"><p></p>
					The important thing is that the splitting of a VG into LVs is entirely independent of its physical components (the PVs). A VG with only a single physical component (a disk for instance) can be split into a dozen logical volumes; similarly, a VG can use several physical disks and appear as a single large logical volume. The only constraint is that obviously the total size allocated to LVs can't be bigger than the total capacity of the PVs in the volume group.
				</div><div class="para"><p></p>
					It often makes sense, however, to have some kind of homogeneity among the physical components of a VG, and to split the VG into logical volumes that will have similar usage patterns. For instance, if the available hardware includes fast disks and slower disks, the fast ones could be clustered into one VG and the slower ones into another; chunks of the first one can then be assigned to applications requiring fast data access, while the second one will be kept for less demanding tasks.
				</div><div class="para"><p></p>
					In any case, keep in mind that an LV isn't particularly attached to any one PV. It is possible to influence where the data from an LV are physically stored, but this possibility isn't required for day-to-day use. On the contrary: when the set of physical components of a VG evolves, the physical storage locations corresponding to a particular LV can be migrated across disks (while staying within the PVs assigned to the VG, of course).
				</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title" id="lvm-mise-en-place">12.1.2.2. Setting up LVM</h4></div></div></div><div class="para"><p></p>
					Let us now follow, step by step, the process of setting up LVM for a typical use case: we want to simplify a complex storage situation. Such a situation usually happens after some long and convoluted history of accumulated temporary measures. For the purposes of illustration, we'll consider a server where the storage needs have changed over time, ending up in a maze of available partitions split over several partially used disks. In more concrete terms, the following partitions are available:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para"><p></p>
							on the <code class="filename">sdb</code> disk, a <code class="filename">sdb2</code> partition, 4 GB;
						</div></li><li class="listitem"><div class="para"><p></p>
							on the <code class="filename">sdc</code> disk, a <code class="filename">sdc3</code> partition, 3 GB;
						</div></li><li class="listitem"><div class="para"><p></p>
							the <code class="filename">sdd</code> disk, 4 GB, in fully available;
						</div></li><li class="listitem"><div class="para"><p></p>
							on the <code class="filename">sdf</code> disk, a <code class="filename">sdf1</code> partition, 4 GB; and a <code class="filename">sdf2</code> partition, 5 GB.
						</div></li></ul></div><div class="para"><p></p>
					In addition, let's assume that disks <code class="filename">sdb</code> and <code class="filename">sdf</code> are faster than the other two.
				</div><div class="para"><p></p>
					Our goal is to set up three logical volumes for three different applications: a file server requiring 5 GB of storage space, a database (1 GB) and some space for back-ups (12 GB). The first two need good performance, but back-ups are less critical in terms of access speed. All these constraints prevent the use of partitions on their own; using LVM can abstract the physical size of the devices, so the only limit is the total available space.
				</div><div class="para"><p></p>
					The required tools are in the <span class="pkg pkg">lvm2</span> package and its dependencies. When they're installed, setting up LVM takes three steps, matching the three levels of concepts.
				</div><div class="para"><p></p>
					First, we prepare the physical volumes using <code class="command">pvcreate</code>:
				</div><a xmlns="" id="screen.pvcreate"></a><pre class="screen"><code class="computeroutput"># </code><strong class="userinput"><code>pvdisplay</code></strong>
<code class="computeroutput"># </code><strong class="userinput"><code>pvcreate /dev/sdb2</code></strong>
<code class="computeroutput">  Physical volume "/dev/sdb2" successfully created
# </code><strong class="userinput"><code>pvdisplay</code></strong>
<code class="computeroutput">
  "/dev/sdb2" is a new physical volume of "4,00 GiB"
  --- NEW Physical volume ---
  PV Name               /dev/sdb2
  VG Name
  PV Size               4.00 GiB
  Allocatable           NO
  PE Size (KByte)       0
  Total PE              0
  Free PE               0
  Allocated PE          0
  PV UUID               9JuaGR-W7jc-pNgj-NU4l-2IX1-kUJ7-m8cRim

# </code><strong class="userinput"><code>for i in sdc3 sdd sdf1 sdf2 ; do pvcreate /dev/$i ; done</code></strong>
<code class="computeroutput">  Physical volume "/dev/sdc3" successfully created
  Physical volume "/dev/sdd" successfully created
  Physical volume "/dev/sdf1" successfully created
  Physical volume "/dev/sdf2" successfully created
# </code><strong class="userinput"><code>pvdisplay -C</code></strong>
<code class="computeroutput">  PV         VG   Fmt  Attr PSize PFree
  /dev/sdb2       lvm2 a-   4.00g 4.00g
  /dev/sdc3       lvm2 a-   3.09g 3.09g
  /dev/sdd        lvm2 a-   4.00g 4.00g
  /dev/sdf1       lvm2 a-   4.10g 4.10g
  /dev/sdf2       lvm2 a-   5.22g 5.22g</code></pre><div class="para"><p></p>
					So far, so good; note that a PV can be set up on a full disk as well as on individual partitions of it. As shown above, the <code class="command">pvdisplay</code> command lists the existing PVs, with two possible output formats.
				</div><div class="para"><p></p>
					Now let's assemble these physical elements into VGs using <code class="command">vgcreate</code>. We'll gather only PVs from the fast disks into a <code class="filename">vg_critical</code> VG; the other VG, <code class="filename">vg_normal</code>, will also include slower elements.
				</div><a xmlns="" id="screen.vgcreate"></a><pre class="screen"><code class="computeroutput"># </code><strong class="userinput"><code>vgdisplay</code></strong>
<code class="computeroutput"># </code><strong class="userinput"><code>vgcreate vg_critical /dev/sdb2 /dev/sdf1</code></strong>
<code class="computeroutput">  Volume group "vg_critical" successfully created
# </code><strong class="userinput"><code>vgdisplay</code></strong>
<code class="computeroutput">  --- Volume group ---
  VG Name               vg_critical
  System ID
  Format                lvm2
  Metadata Areas        2
  Metadata Sequence No  1
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                0
  Open LV               0
  Max PV                0
  Cur PV                2
  Act PV                2
  VG Size               8.14 GB
  PE Size               4.00 MB
  Total PE              2084
  Alloc PE / Size       0 / 0
  Free  PE / Size       2084 / 8.14 GB
  VG UUID               6eG6BW-MmJE-KB0J-dsB2-52iL-N6eD-1paeo8

# </code><strong class="userinput"><code>vgcreate vg_normal /dev/sdc3 /dev/sdd /dev/sdf2</code></strong>
<code class="computeroutput">  Volume group "vg_normal" successfully created
# </code><strong class="userinput"><code>vgdisplay -C</code></strong>
<code class="computeroutput">  VG          #PV #LV #SN Attr   VSize  VFree
  vg_critical   2   0   0 wz--n-  8.14g  8.14g
  vg_normal     3   0   0 wz--n- 12.30g 12.30g</code></pre><div class="para"><p></p>
					Here again, commands are rather straightforward (and <code class="command">vgdisplay</code> proposes two output formats). Note that it's quite possible to use two partitions of the same physical disk into two different VGs. Note also that we used a <code class="filename">vg_</code> prefix to name our VGs, but it's nothing more than a convention.
				</div><div class="para"><p></p>
					We now have two “virtual disks”, sized about 8 GB and 12 GB, respectively. Let's now carve them up into “virtual partitions” (LVs). This involves the <code class="command">lvcreate</code> command, and a slightly more complex syntax:
				</div><a xmlns="" id="screen.lvcreate"></a><pre class="screen"><code class="computeroutput"># </code><strong class="userinput"><code>lvdisplay</code></strong>
<code class="computeroutput"># </code><strong class="userinput"><code>lvcreate -n lv_files -L 5G vg_critical</code></strong>
<code class="computeroutput">  Logical volume "lv_files" created
# </code><strong class="userinput"><code>lvdisplay</code></strong>
<code class="computeroutput">  --- Logical volume ---
  LV Name                /dev/vg_critical/lv_files
  VG Name                vg_critical
  LV UUID                4QLhl3-2cON-jRgQ-X4eT-93J4-6Ox9-GyRx3M
  LV Write Access        read/write
  LV Status              available
  # open                 0
  LV Size                5.00 GB
  Current LE             1280
  Segments               2
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     256
  Block device           253:0

# </code><strong class="userinput"><code>lvcreate -n lv_base -L 1G vg_critical</code></strong>
<code class="computeroutput">  Logical volume "lv_base" created
# </code><strong class="userinput"><code>lvcreate -n lv_backups -L 12G vg_normal</code></strong>
<code class="computeroutput">  Logical volume "lv_backups" created
# </code><strong class="userinput"><code>lvdisplay -C</code></strong>
<code class="computeroutput">  LV         VG          Attr   LSize  Origin Snap%  Move Log Copy%  Convert
  lv_base    vg_critical -wi-a-  1.00G
  lv_files   vg_critical -wi-a-  5.00G
  lv_backups vg_normal   -wi-a- 12.00G</code></pre><div class="para"><p></p>
					Two parameters are required when creating logical volumes; they must be passed to the <code class="command">lvcreate</code> as options. The name of the LV to be created is specified with the <code class="literal">-n</code> option, and its size is generally given using the <code class="literal">-L</code> option. We also need to tell the command what VG to operate on, of course, hence the last parameter on the command line.
				</div><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>GOING FURTHER</em></span> <code class="command">lvcreate</code> options</h6></div></div></div><div class="para"><p></p>
					The <code class="command">lvcreate</code> command has several options to allow tweaking how the LV is created.
				</div><div class="para"><p></p>
					Let's first describe the <code class="literal">-l</code> option, with which the LV's size can be given as a number of blocks (as opposed to the “human” units we used above). These blocks (called PEs, <span class="emphasis"><em>physical extents</em></span>, in LVM terms) are contiguous units of storage space in PVs, and they can't be split across LVs. When one wants to define storage space for an LV with some precision, for instance to use the full available space, the <code class="literal">-l</code> option will probably be preferred over <code class="literal">-L</code>.
				</div><div class="para"><p></p>
					It's also possible to hint at the physical location of an LV, so that its extents are stored on a particular PV (while staying within the ones assigned to the VG, of course). Since we know that <code class="filename">sdb</code> is faster than <code class="filename">sdf</code>, we may want to store the <code class="filename">lv_base</code> there if we want to give an advantage to the database server compared to the file server. The command line becomes: <code class="command">lvcreate -n lv_base -L 1G vg_critical /dev/sdb2</code>. Note that this command can fail if the PV doesn't have enough free extents. In our example, we would probably have to create <code class="filename">lv_base</code> before <code class="filename">lv_files</code> to avoid this situation – or free up some space on <code class="filename">sdb2</code> with the <code class="command">pvmove</code> command.
				</div></div><div class="para"><p></p>
					Logical volumes, once created, end up as block device files in <code class="filename">/dev/mapper/</code>:
				</div><pre class="screen"><code class="computeroutput"># </code><strong class="userinput"><code>ls -l /dev/mapper</code></strong>
<code class="computeroutput">total 0
crw-rw---- 1 root root  10, 59  5 oct.  17:40 control
lrwxrwxrwx 1 root root       7  5 oct.  18:14 vg_critical-lv_base -&gt; ../dm-1
lrwxrwxrwx 1 root root       7  5 oct.  18:14 vg_critical-lv_files -&gt; ../dm-0
lrwxrwxrwx 1 root root       7  5 oct.  18:14 vg_normal-lv_backups -&gt; ../dm-2
# </code><strong class="userinput"><code>ls -l /dev/dm-*</code></strong>
<code class="computeroutput">brw-rw---- 1 root disk 253,  0  5 oct.  18:14 /dev/dm-0
brw-rw---- 1 root disk 253,  1  5 oct.  18:14 /dev/dm-1
brw-rw---- 1 root disk 253,  2  5 oct.  18:14 /dev/dm-2</code></pre><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>NOTE</em></span> Autodetecting LVM volumes</h6></div></div></div><div class="para"><p></p>
					When the computer boots, the <code class="filename">/etc/init.d/lvm</code> script scans the available devices; those that have been initialised as physical volumes for LVM are registered into the LVM subsystem, those that belong to volume groups are assembled, and the relevant logical volumes are started and made available. There is therefore no need to edit configuration files when creating or modifying LVM volumes.
				</div><div class="para"><p></p>
					Note, however, that the layout of the LVM elements (physical and logical volumes, and volume groups) is backed up in <code class="filename">/etc/lvm/backup</code>, which can be useful in case of a problem (or just to sneak a peek under the hood).
				</div></div><div class="para"><p></p>
					To make things easier, convenience symbolic links are also created in directories matching the VGs:
				</div><pre class="screen"><code class="computeroutput"># </code><strong class="userinput"><code>ls -l /dev/vg_critical</code></strong>
<code class="computeroutput">total 0
lrwxrwxrwx 1 root root 7  5 oct.  18:14 lv_base -&gt; ../dm-1
lrwxrwxrwx 1 root root 7  5 oct.  18:14 lv_files -&gt; ../dm-0
# </code><strong class="userinput"><code>ls -l /dev/vg_normal</code></strong>
<code class="computeroutput">total 0
lrwxrwxrwx 1 root root 7  5 oct.  18:14 lv_backups -&gt; ../dm-2</code></pre><div class="para"><p></p>
					The LVs can then be used exactly like standard partitions:
				</div><pre class="screen"><code class="computeroutput"># </code><strong class="userinput"><code>mkfs.ext4 /dev/vg_normal/lv_backups</code></strong>
<code class="computeroutput">mke2fs 1.41.12 (17-May-2010)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
[...]
This filesystem will be automatically checked every 34 mounts or
180 days, whichever comes first.  Use tune2fs -c or -i to override.
# </code><strong class="userinput"><code>mkdir /srv/backups</code></strong>
<code class="computeroutput"># </code><strong class="userinput"><code>mount /dev/vg_normal/lv_backups /srv/backups</code></strong>
<code class="computeroutput"># </code><strong class="userinput"><code>df -h /srv/backups</code></strong>
<code class="computeroutput">Filesystem            Size  Used Avail Use% Mounted on
/dev/mapper/vg_normal-lv_backups
                       12G  159M   12G   2% /srv/backups
# </code><strong class="userinput"><code>[...]</code></strong>
<code class="computeroutput">[...]
# </code><strong class="userinput"><code>cat /etc/fstab</code></strong>
<code class="computeroutput">[...]
/dev/vg_critical/lv_base    /srv/base       ext4
/dev/vg_critical/lv_files   /srv/files      ext4
/dev/vg_normal/lv_backups   /srv/backups    ext4</code></pre><div class="para"><p></p>
					From the applications' point of view, the myriad small partitions have now been abstracted into one large 12 GB volume, with a friendlier name.
				</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title" id="lvm-dans-le-temps">12.1.2.3. LVM Over Time</h4></div></div></div><div class="para"><p></p>
					Even though the ability to aggregate partitions or physical disks is convenient, this is not the main advantage brought by LVM. The flexibility it brings is especially noticed as time passes, when needs evolve. In our example, let's assume that new large files must be stored, and that the LV dedicated to the file server is too small to contain them. Since we haven't used the whole space available in <code class="filename">vg_critical</code>, we can grow <code class="filename">lv_files</code>. For that purpose, we'll use the <code class="command">lvresize</code> command, then <code class="command">resize2fs</code> to adapt the filesystem accordingly:
				</div><pre class="screen"><code class="computeroutput"># </code><strong class="userinput"><code>df -h /srv/files/</code></strong>
<code class="computeroutput">Filesystem            Size  Used Avail Use% Mounted on/dev/mapper/vg_critical-lv_files                      5.0G  4.6G  142M  98% /srv/files
# </code><strong class="userinput"><code>lvdisplay -C vg_critical/lv_files</code></strong>
<code class="computeroutput">  LV       VG          Attr   LSize Origin Snap%  Move Log Copy%  Convert
  lv_files vg_critical -wi-ao 5.00g
# </code><strong class="userinput"><code>vgdisplay -C vg_critical</code></strong>
<code class="computeroutput">  VG          #PV #LV #SN Attr   VSize VFree
  vg_critical   2   2   0 wz--n- 8.14g 2.14g
# </code><strong class="userinput"><code>lvresize -L 7G vg_critical/lv_files</code></strong>
<code class="computeroutput">  Extending logical volume lv_files to 7.00 GB
  Logical volume lv_files successfully resized
# </code><strong class="userinput"><code>lvdisplay -C vg_critical/lv_files</code></strong>
<code class="computeroutput">  LV       VG          Attr   LSize Origin Snap%  Move Log Copy%  Convert
  lv_files vg_critique -wi-ao 7.00g
# </code><strong class="userinput"><code>resize2fs /dev/vg_critical/lv_files</code></strong>
<code class="computeroutput">resize2fs 1.41.12 (17-May-2010)
Filesystem at /dev/vg_critical/lv_files is mounted on /srv/files; on-line resizing required
old desc_blocks = 1, new_desc_blocks = 1
Performing an on-line resize of /dev/vg_critical/lv_files to 1835008 (4k) blocks.
The filesystem on /dev/vg_critical/lv_files is now 1835008 blocks long.

# </code><strong class="userinput"><code>df -h /srv/files/</code></strong>
<code class="computeroutput">Filesystem            Size  Used Avail Use% Mounted on
/dev/mapper/vg_critical-lv_files
                      6.9G  4.6G  2.1G  70% /srv/files</code></pre><div class="sidebar important"><div class="titlepage"><div><div><h6><span class="emphasis"><em>CAUTION</em></span> Resizing filesystems</h6></div></div></div><div class="para"><p></p>
					Not all filesystems can be resized online; resizing a volume can therefore require unmounting the filesystem first and remounting it afterwards. Of course, if one wants to shrink the space allocated to an LV, the filesystem must be shrunk first; the order is reversed when the resizing goes in the other direction: the logical volume must be grown before the filesystem on it. It's rather straightforward, since at no time must the filesystem size be larger than the block device where it resides (whether that device is a physical partition or a logical volume).
				</div><div class="para"><p></p>
					The ext3, ext4 and xfs filesystems can be grown online, without unmounting; shrinking requires an unmount. The reiserfs filesystem allows online resizing in both directions. The venerable ext2 allows neither, and always requires unmounting.
				</div></div><div class="para"><p></p>
					We could proceed in a similar fashion to extend the volume hosting the database, only we've reached the VG's available space limit:
				</div><pre class="screen"><code class="computeroutput"># </code><strong class="userinput"><code>df -h /srv/base/</code></strong>
<code class="computeroutput">Filesystem            Size  Used Avail Use% Mounted on
/dev/mapper/vg_critical-lv_base
                     1008M  835M  123M  88% /srv/base
# </code><strong class="userinput"><code>vgdisplay -C vg_critical</code></strong>
<code class="computeroutput">  VG          #PV #LV #SN Attr   VSize VFree
  vg_critical   2   2   0 wz--n- 8.14g 144.00m</code></pre><div class="para"><p></p>
					No matter, since LVM allows adding physical volumes to existing volume groups. For instance, maybe we've noticed that the <code class="filename">sdb1</code> partition, which was so far used outside of LVM, only contained archives that could be moved to <code class="filename">lv_backups</code>. We can now recycle it and integrate it to the volume group, and thereby reclaim some available space. This is the purpose of the <code class="command">vgextend</code> command. Of course, the partition must be prepared as a physical volume beforehand. Once the VG has been extended, we can use similar commands as previously to grow the logical volume then the filesystem:
				</div><pre class="screen"><code class="computeroutput"># </code><strong class="userinput"><code>pvcreate /dev/sdb1</code></strong>
<code class="computeroutput">  Physical volume "/dev/sdb1" successfully created
# </code><strong class="userinput"><code>vgextend vg_critical /dev/sdb1</code></strong>
<code class="computeroutput">  Volume group "vg_critical" successfully extended
# </code><strong class="userinput"><code>vgdisplay -C vg_critical</code></strong>
<code class="computeroutput">  VG          #PV #LV #SN Attr   VSize VFree
  vg_critical   3   2   0 wz--n- 9.09g 1.09g
# </code><strong class="userinput"><code>[...]</code></strong>
<code class="computeroutput">[...]
# </code><strong class="userinput"><code>df -h /srv/base/</code></strong>
<code class="computeroutput">Filesystem            Size  Used Avail Use% Mounted on
/dev/mapper/vg_critical-lv_base
                      2.0G  835M  1.1G  44% /srv/base</code></pre><div class="sidebar fil"><div class="titlepage"><div><div><h6><span class="emphasis"><em>GOING FURTHER</em></span> Advanced LVM</h6></div></div></div><div class="para"><p></p>
					LVM also caters for more advanced uses, where many details can be specified by hand. For instance, an administrator can tweak the size of the blocks that make up physical and logical volumes, as well as their physical layout. It is also possible to move blocks across PVs, for instance to fine-tune performance or, in a more mundane way, to free a PV when one needs to extract the corresponding physical disk from the VG (whether to affect it to another VG or to remove it from LVM altogether). The manual pages describing the commands are generally clear and detailed. A good entry point is the <span class="citerefentry"><span class="refentrytitle">lvm</span>(8)</span> manual page.
				</div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title" id="raid-ou-lvm">12.1.3. RAID or LVM?</h3></div></div></div><div class="para"><p></p>
				RAID and LVM both bring undisputable advantages as soon as one leaves the simple case of a desktop computer with a single hard disk where the usage pattern doesn't change over time. However, RAID and LVM go in two different directions, with diverging goals, and it is legitimate to wonder which one should be adopted. The most appropriate answer will of course depend on current and foreseeable requirements.
			</div><div class="para"><p></p>
				There are a few simple cases where the question doesn't really arise. If the requirement is to safeguard data against hardware failures, then obviously RAID will be set up on a redundant array of disks, since LVM doesn't really address this problem. If, on the other hand, the need is for a flexible storage scheme where the volumes are made independent of the physical layout of the disks, RAID doesn't help much and LVM will be the natural choice.
			</div><div class="para"><p></p>
				The third notable use case is when one just wants to aggregate two disks into one volume, either for performance reasons or to have a single filesystem that is larger than any of the available disks. This case can be addressed both by a RAID-0 (or even linear-RAID) and by an LVM volume. When in this situation, and barring extra constraints (keeping in line with the rest of the computers if they only use RAID), the configuration of choice will often be LVM. The initial set up is slightly more complex, but that slight increase in complexity more than makes up for the extra flexibility that LVM brings if the requirements change or if new disks need to be added.
			</div><div class="para"><p></p>
				Then of course, there is the really interesting use case, where the storage system needs to be made both resistant to hardware failure and flexible when it comes to volume allocation. Neither RAID nor LVM can address both requirements on their own; no matter, this is where we use both at the same time — or rather, one on top of the other. The scheme that has all but become a standard since RAID and LVM have reached maturity is to ensure data redundancy first by grouping disks in a small number of large RAID arrays, and to use these RAID arrays as LVM physical volumes; logical partitions will then be carved from these LVs for filesystems. The selling point of this setup is that when a disk fails, only a small number of RAID arrays will need to be reconstructed, thereby limiting the time spent by the administrator for recovery.
			</div><div class="para"><p></p>
				Let's take a concrete example: the public relations department at Falcot Corp needs a workstation for video editing, but the department's budget doesn't allow investing in high-end hardware from the bottom up. A decision is made to favour the hardware that is specific to the graphic nature of the work (monitor and video card), and to stay with generic hardware for storage. However, as is widely known, digital video does have some particular requirements for its storage: the amount of data to store is large, and the throughput rate for reading and writing this data is important for the overall system performance (more than typical access time, for instance). These constraints need to be fulfilled with generic hardware, in this case two 300 GB SATA hard disk drives; the system data must also be made resistant to hardware failure, as well as some of the user data. Edited videoclips must indeed be safe, but video rushes pending editing are less critical, since they're still on the videotapes.
			</div><div class="para"><p></p>
				RAID-1 and LVM are combined to satisfy these constraints. The disks are attached to two different SATA controllers to optimize parallel access and reduce the risk of a simultaneous failure, and they therefore appear as <code class="filename">sda</code> and <code class="filename">sdc</code>. They are partitioned identically along the following scheme:
			</div><pre class="screen"><code class="computeroutput"># </code><strong class="userinput"><code>fdisk -l /dev/sda</code></strong>
<code class="computeroutput">
Disk /dev/hda: 300.0 GB, 300090728448 bytes
255 heads, 63 sectors/track, 36483 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x00039a9f

   Device Boot      Start      End      Blocks   Id  System
/dev/sda1   *           1      124      995998+  fd  Linux raid autodetect
/dev/sda2             125      248      996030   82  Linux swap / Solaris
/dev/sda3             249    36483   291057637+   5  Extended
/dev/sda5             249    12697    99996561   fd  Linux raid autodetect
/dev/sda6           12698    25146    99996561   fd  Linux raid autodetect
/dev/sda7           25147    36483    91064421   8e  Linux LVM</code></pre><div class="itemizedlist"><ul><li class="listitem"><div class="para"><p></p>
						The first partitions of both disks (about 1 GB) are assembled into a RAID-1 volume, <code class="filename">md0</code>. This mirror is directly used to store the root filesystem.
					</div></li><li class="listitem"><div class="para"><p></p>
						The <code class="filename">sda2</code> and <code class="filename">sdc2</code> partitions are used as swap partitions, providing a total 2 GB of swap space. With 1 GB of RAM, the workstation has a comfortable amount of available memory.
					</div></li><li class="listitem"><div class="para"><p></p>
						The <code class="filename">sda5</code> and <code class="filename">sdc5</code> partitions, as well as <code class="filename">sda6</code> and <code class="filename">sdc6</code>, are assembled into two new RAID-1 volumes of about 100 GB each, <code class="filename">md1</code> and <code class="filename">md2</code>. Both these mirrors are initialized as physical volumes for LVM, and assigned to the <code class="filename">vg_raid</code> volume group. This VG thus contains about 200 GB of safe space.
					</div></li><li class="listitem"><div class="para"><p></p>
						The remaining partitions, <code class="filename">sda7</code> and <code class="filename">sdc7</code>, are directly used as physical volumes, and assigned to another VG called <code class="filename">vg_bulk</code>, which therefore ends up with roughly 200 GB of space.
					</div></li></ul></div><div class="para"><p></p>
				Once the VGs are created, they can be partitioned in a very flexible way. One must keep in mind that LVs created in <code class="filename">vg_raid</code> will be preserved even if one of the disks fails, which will not be the case for LVs created in <code class="filename">vg_bulk</code>; on the other hand, the latter will be allocated in parallel on both disks, which allows higher read or write speeds for large files.
			</div><div class="para"><p></p>
				We'll therefore create the <code class="filename">lv_usr</code>, <code class="filename">lv_var</code> and <code class="filename">lv_home</code> LVs on <code class="filename">vg_raid</code>, to host the matching filesystems; another large LV, <code class="filename">lv_movies</code>, will be used to host the definitive versions of movies after editing. The other VG will be split into a large <code class="filename">lv_rushes</code>, for data straight out of the digital video cameras, and a <code class="filename">lv_tmp</code> for temporary files. The location of the work area is a less straightforward choice to make: while good performance is needed for that volume, is it worth risking losing work if a disk fails during an editing session? Depending on the answer to that question, the relevant LV will be created on one VG or the other.
			</div><div class="para"><p></p>
				We now have both some redundancy for important data and much flexibility in how the available space is split across the applications. Should new software be installed later on (for editing audio clips, for instance), the LV hosting <code class="filename">/usr/</code> can be grown painlessly.
			</div><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>NOTE</em></span> Why three RAID-1 volumes?</h6></div></div></div><div class="para"><p></p>
				We could have set up one RAID-1 volume only, to serve as a physical volume for <code class="filename">vg_raid</code>. Why create three of them, then?
			</div><div class="para"><p></p>
				The rationale for the first split (<code class="filename">md0</code> vs. the others) is about data safety: data written to both elements of a RAID-1 mirror are exactly the same, and it is therefore possible to bypass the RAID layer and mount one of the disks directly. In case of a kernel bug, for instance, or if the LVM metadata become corrupted, it is still possible to boot a minimal system to access critical data such as the layout of disks in the RAID and LVM volumes; the metadata can then be reconstructed and the files can be accessed again, so that the system can be brought back to its nominal state.
			</div><div class="para"><p></p>
				The rationale for the second split (<code class="filename">md1</code> vs. <code class="filename">md2</code>) is less clear-cut, and more related to acknowledging that the future is uncertain. When the workstation is first assembled, the exact storage requirements are not necessarily known with perfect precision; they can also evolve over time. In our case, we can't know in advance the actual storage space requirements for video rushes and complete video clips. If one particular clip needs a very large amount of rushes, and the VG dedicated to redundant data is less than halfway full, we can re-use some of its unneeded space. We can remove one of the physical volumes, say <code class="filename">md2</code> from <code class="filename">vg_raid</code> and either assign it to <code class="filename">vg_bulk</code> directly (if the expected duration of the operation is short enough that we can live with the temporary drop in performance), or undo the RAID setup on <code class="filename">md2</code> and integrate its components <code class="filename">sda6</code> and <code class="filename">sdc6</code> into the bulk VG (which grows by 200 GB instead of 100 GB); the <code class="filename">lv_rushes</code> logical volume can then be grown according to requirements.
			</div></div></div></div></div><div id="site_footer"></div><script type="text/javascript">
		$("#site_footer").load("../../../../../footer.html");
	</script><ul class="docnav"><li class="previous"><a accesskey="p" href="sect.ldap-directory.html"><strong>Prev</strong>11.7. LDAP Directory</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="sect.virtualization.html"><strong>Next</strong>12.2. Virtualization</a></li></ul></body></html>
